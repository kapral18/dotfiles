#!/usr/bin/env bash

set -euo pipefail

function show_help() {
  cat <<EOF
Usage: f-tmux-run-all <pattern> [exclude_pattern] <command>

Run a command in multiple tmux sessions matching a pattern.

Arguments:
    pattern         Pattern to match session names (supports wildcards)
    exclude_pattern Optional pattern to exclude sessions (supports wildcards)
    command         Command to run in matching sessions

Examples:
    f-tmux-run-all "work-*" "git status"
    f-tmux-run-all "dev-*" "*test*" "npm run build"
    f-tmux-run-all "*" "main" "echo 'hello world'"

Notes:
    - Uses shell pattern matching (*, ?, [])
    - If exclude_pattern is omitted, no sessions are excluded
    - Command is executed in idle shell panes of each matching session
    - Set F_TMUX_RUN_ALL_ALLOWED_SHELLS to override idle shell detection
    - Sessions that don't exist or aren't accessible are skipped
EOF
}

function log_info() {
  echo "ℹ️  $1" >&2
}

function log_error() {
  echo "❌ $1" >&2
}

function get_allowed_shells() {
  if [[ -n "${F_TMUX_RUN_ALL_ALLOWED_SHELLS:-}" ]]; then
    echo "$F_TMUX_RUN_ALL_ALLOWED_SHELLS"
    return
  fi

  echo "bash zsh fish sh"
}

function is_idle_shell() {
  local command="$1"
  local allowed_shells
  allowed_shells=$(get_allowed_shells)

  for shell in $allowed_shells; do
    if [[ "$command" == "$shell" ]]; then
      return 0
    fi
  done

  return 1
}

function validate_tmux() {
  if ! command -v tmux >/dev/null 2>&1; then
    log_error "tmux is not installed or not in PATH"
    exit 1
  fi

  if ! tmux list-sessions >/dev/null 2>&1; then
    log_error "No tmux server is running or no sessions exist"
    exit 1
  fi
}

function get_matching_sessions() {
  local pattern="$1"
  local exclude_pattern="${2:-}"

  local sessions
  sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

  if [[ -z "$sessions" ]]; then
    return 0
  fi

  local matching_sessions=()

  while IFS= read -r session; do
    # Check if session matches the include pattern
    if [[ $session == $pattern ]]; then
      # Check if session should be excluded
      if [[ -n "$exclude_pattern" && $session == $exclude_pattern ]]; then
        continue
      fi
      matching_sessions+=("$session")
    fi
  done <<<"$sessions"

  # Only print if we have matches
  if [[ ${#matching_sessions[@]} -gt 0 ]]; then
    printf '%s\n' "${matching_sessions[@]}"
  fi
}

function run_command_in_session() {
  local session="$1"
  local command="$2"

  mapfile -t session_panes < <(tmux list-panes -t "$session" -F '#{pane_id}	#{session_name}:#{window_index}.#{pane_index}	#{pane_current_command}' 2>/dev/null || true)

  if [[ ${#session_panes[@]} -eq 0 ]]; then
    printf '0 0\n'
    log_error "No panes found for session '$session'"
    return 1
  fi

  log_info "Running command in ${#session_panes[@]} pane(s) of session '$session'"

  local trimmed=()
  for entry in "${session_panes[@]}"; do
    trimmed+=("${entry%%$'\r'}")
  done
  session_panes=("${trimmed[@]}")

  local success_count=0
  local failure_count=0
  local skipped_count=0

  local current_pane_id="${TMUX_PANE:-}"
  local CURRENT_PANE_ID="$current_pane_id"
  local current_pane_command=""
  local current_pane_display=""
  local current_pane_info=""
  local pane_queue=()

  for pane_info in "${session_panes[@]}"; do
    pane_id="${pane_info%%$'\t'*}"
    rest="${pane_info#*$'\t'}"
    pane_display="${rest%%$'\t'*}"
    pane_command="${rest#*$'\t'}"

    if [[ "$pane_id" == "$CURRENT_PANE_ID" ]]; then
      current_pane_command="$pane_command"
      current_pane_display="$pane_display"
      current_pane_info="$pane_info"
      continue
    fi

    if ! is_idle_shell "$pane_command"; then
      log_info "Skipping pane '$pane_display' (active command: $pane_command)"
      skipped_count=$((skipped_count + 1))
      continue
    fi

    pane_queue+=("$pane_info")
  done

  if [[ -n "$CURRENT_PANE_ID" ]]; then
    if [[ -n "$current_pane_info" ]]; then
      pane_queue=("$current_pane_info" "${pane_queue[@]}")
    fi
  fi

  for pane_info in "${pane_queue[@]}"; do
    pane_id="${pane_info%%$'\t'*}"
    rest="${pane_info#*$'\t'}"
    pane_display="${rest%%$'\t'*}"
    pane_command="${rest#*$'\t'}"

    if [[ "$pane_id" == "$CURRENT_PANE_ID" ]]; then
      if ! is_idle_shell "$pane_command"; then
        log_info "Skipping current pane '$pane_display' (active command: $pane_command)"
        skipped_count=$((skipped_count + 1))
        continue
      fi
    else
      if ! is_idle_shell "$pane_command"; then
        log_info "Skipping pane '$pane_display' (active command: $pane_command)"
        skipped_count=$((skipped_count + 1))
        continue
      fi
    fi

    if tmux send-keys -t "$pane_id" "$command" Enter 2>/dev/null; then
      success_count=$((success_count + 1))
    else
      log_error "Failed to send command to pane '$pane_display'"
      failure_count=$((failure_count + 1))
    fi
  done

  printf '%s %s %s\n' "$success_count" "$failure_count" "$skipped_count"

  if [[ $failure_count -gt 0 ]]; then
    log_error "Session '$session': $failure_count pane(s) failed"
    return 1
  fi

  return 0
}


function main() {
  local pattern=""
  local exclude_pattern=""
  local command=""

  # Parse arguments
  case $# in
  0 | 1)
    show_help
    exit 1
    ;;
  2)
    pattern="$1"
    command="$2"
    ;;
  3)
    pattern="$1"
    exclude_pattern="$2"
    command="$3"
    ;;
  *)
    log_error "Too many arguments"
    show_help
    exit 1
    ;;
  esac

  # Handle help flags
  if [[ "$pattern" == "-h" || "$pattern" == "--help" ]]; then
    show_help
    exit 0
  fi

  # Validate tmux is available
  validate_tmux

  # Get matching sessions
  local matching_sessions
  mapfile -t matching_sessions < <(get_matching_sessions "$pattern" "$exclude_pattern")

  if [[ ${#matching_sessions[@]} -eq 0 ]]; then
    log_error "No sessions match pattern '$pattern'"
    if [[ -n "$exclude_pattern" ]]; then
      log_error "  (excluding pattern '$exclude_pattern')"
    fi
    exit 1
  fi

  log_info "Found ${#matching_sessions[@]} matching session(s)"

  # Run command in each matching session
  local sessions_success_count=0
  local sessions_failure_count=0
  local panes_success=0
  local panes_failure=0
  local panes_skipped=0

  for session in "${matching_sessions[@]}"; do
    if output=$(run_command_in_session "$session" "$command"); then
      status=0
    else
      status=$?
      log_error "Session '$session' failed to run command"
    fi

    read -r session_success session_failure session_skipped <<<"$output"
    panes_success=$((panes_success + session_success))
    panes_failure=$((panes_failure + session_failure))
    panes_skipped=$((panes_skipped + session_skipped))

    if [[ $status -eq 0 ]]; then
      sessions_success_count=$((sessions_success_count + 1))
    else
      sessions_failure_count=$((sessions_failure_count + 1))
    fi
  done

  # Summary
  echo
  log_info "Sessions: $sessions_success_count successful, $sessions_failure_count failed"
  log_info "Panes: $panes_success successful, $panes_failure failed, $panes_skipped skipped"

  if [[ $sessions_failure_count -gt 0 || $panes_failure -gt 0 ]]; then
    exit 1
  fi
}

main "$@"
